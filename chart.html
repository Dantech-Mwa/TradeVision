<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TradeVision Pro</title>
	<!-- Essential Open Graph Tags -->
    <meta property="og:title" content="ProChart - The Ultimate Free Trading Analysis Platform" />
    <meta property="og:description" content="10+ indicators & advanced drawing tools. For all traders, from beginner to professional. Completely free." />
    <meta property="og:image" content="https://tradevision.jaydancosmeticshop.store/components/twitter-preview-chart.JPG" />
    <meta property="og:url" content="https://prochart.com" />

    <!-- Essential Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ProChart - The Ultimate Free Trading Analysis Platform">
    <meta name="twitter:description" content="10+ indicators & advanced drawing tools. For all traders. Completely free.">
    <meta name="twitter:image" content="https://tradevision.jaydancosmeticshop.store/components/twitter-preview-chart.JPG">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    /* All CSS remains exactly the same as your original */
    :root {
      --bg: #131722;
      --bg2: #1a1d24;
      --panel: #14171b;
      --muted: #9ea1b5;
      --accent: #338fff;
      --up: #26a69a;
      --down: #ef5350;
      --border: #2c2e35;
      --card: #1e222d;
      --text: #d1d4dc;
      --chart-bg: #131722;
      --chart-grid: #1e222d;
      --chart-text: #d1d4dc;
      --chart-border: #2c2e35;
    }
    
    [data-theme="light"] {
      --bg: #ffffff;
      --bg2: #f8f9fa;
      --panel: #f1f3f4;
      --muted: #718096;
      --accent: #2962ff;
      --up: #26a69a;
      --down: #ef5350;
      --border: #e2e8f0;
      --card: #ffffff;
      --text: #2d3748;
      --chart-bg: #ffffff;
      --chart-grid: #f1f3f4;
      --chart-text: #2d3748;
      --chart-border: #e2e8f0;
    }
    
    *, *::before, *::after {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      transition: background-color 0.3s, color 0.3s;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    a {
      color: var(--accent);
      text-decoration: none;
      transition: color 0.2s;
    }
    
    /* Header */
    .header {
      height: 56px;
      background: var(--bg2);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 8px 12px;
      gap: 12px;
      position: sticky;
      top: 0;
      z-index: 200;
    }
    
    .logo {
      color: var(--accent);
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
    }
    
    .logo i {
      font-size: 18px;
    }
    
    .search {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
      flex: 1;
    }
    
    .search input {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      width: 100%;
      max-width: 260px;
    }
    
    .btn {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    
    .btn:hover {
      background: var(--bg);
    }
    
    .btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    
    .header-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      transition: all 0.2s;
    }
    
    .icon-btn:hover {
      color: var(--accent);
      background: var(--border);
    }
    
    /* Layout */
    .layout {
      display: grid;
      grid-template-columns: 72px 1fr 320px;
      height: calc(100vh - 56px - 40px);
      overflow: hidden;
      flex: 1;
    }
    
    .left-bar {
      background: var(--bg2);
      border-right: 1px solid var(--border);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: auto;
    }
    
    .left-bar .tool-btn {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--muted);
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .left-bar .tool-btn:hover {
      background: var(--bg);
    }
    
    .left-bar .tool-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    
    .center {
      background: var(--bg);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    
    .right-panel {
      background: var(--bg2);
      border-left: 1px solid var(--border);
      padding: 12px;
      overflow-y: auto;
    }
    
    /* Chart area with embedded top toolbar */
    .chart-topbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
    }
    
    .chart-topbar .left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chart-topbar .right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chart-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    
    .pane {
      position: relative;
      border-top: 1px solid var(--border);
      display: flex;
      align-items: stretch;
      min-height: 0 !important;
      flex-shrink: 0;
    }
    
    #pricePane {
      flex: 3;
      min-height: 300px;
    }
    
    #volumePane {
      flex: 1;
      min-height: 100px;
      height: 100px !important;
    }
    
    #indicatorPanes {
      display: flex;
      flex-direction: column;
    }
    
    .indicator-pane {
      flex: 1;
      min-height: 120px;
    }
    
    .chart-inner {
      width: 100%;
      height: 100%;
      min-height: 0 !important;
    }
    
    /* Floating chart controls */
    .chart-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 6px;
      z-index: 40;
    }
    
    .chart-controls button {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 8px;
      color: var(--muted);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .chart-controls button:hover {
      color: var(--accent);
      background: var(--bg);
    }
    
    /* Drawing overlay canvas */
    #drawing-canvas {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      z-index: 30;
      pointer-events: auto;
      cursor: crosshair;
    }
    
    /* Right panel orderbook/trades */
    .tab-buttons {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    
    .tab-buttons button {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--card);
      cursor: pointer;
      color: var(--muted);
      transition: all 0.2s;
    }
    
    .tab-buttons button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    
    .orderbook {
      display: flex;
      gap: 8px;
    }
    
    .orderbook .col {
      flex: 1;
      font-size: 13px;
    }
    
    .orderbook .row {
      display: flex;
      justify-content: space-between;
      padding: 4px 6px;
      border-bottom: 1px solid var(--border);
    }
    
    .orderbook .row.bid {
      background: linear-gradient(90deg, rgba(38, 166, 154, 0.1) 0%, transparent 100%);
    }
    
    .orderbook .row.ask {
      background: linear-gradient(90deg, rgba(239, 83, 80, 0.1) 0%, transparent 100%);
    }
    
    .trades .trade {
      display: flex;
      justify-content: space-between;
      padding: 6px;
      border-bottom: 1px solid var(--border);
      font-size: 13px;
    }
    
    .trades .trade.buy {
      background: linear-gradient(90deg, rgba(38, 166, 154, 0.1) 0%, transparent 100%);
    }
    
    .trades .trade.sell {
      background: linear-gradient(90deg, rgba(239, 83, 80, 0.1) 0%, transparent 100%);
    }
    
    /* Indicator modal - embedded at top */
    .indicator-modal, .timeframe-modal {
      position: absolute;
      left: 12px;
      top: 52px;
      z-index: 1000;
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .timeframe-modal {
      left: 200px;
    }
    
    .indicator-list, .timeframe-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .timeframe-list {
      grid-template-columns: repeat(3, 1fr);
    }
    
    .indicator-item, .timeframe-item {
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: transparent;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    
    .indicator-item:hover, .timeframe-item:hover {
      background: var(--bg);
    }
    
    .indicator-item.active, .timeframe-item.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    
    /* Search suggestions */
    .search-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--card);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 6px 6px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: none;
    }
    
    .suggestion-item {
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .suggestion-item:hover {
      background: var(--bg);
    }
    
    .suggestion-item:last-child {
      border-bottom: none;
    }
    
    .suggestion-symbol {
      font-weight: 600;
      color: var(--text);
    }
    
    .suggestion-name {
      font-size: 0.85rem;
      color: var(--muted);
    }
    
    .suggestion-exchange {
      font-size: 0.75rem;
      color: var(--muted);
      background: var(--accent);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }
    
    /* AI Panel */
    .ai-panel {
      margin-top: 1rem;
      position: relative;
      z-index: 30;
    }
    
    #tradevision-ai-btn {
      font-weight: 600;
      transition: all 0.3s ease;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.6rem;
      width: 100%;
      cursor: pointer;
      margin-bottom: 0.5rem;
    }
    
    #tradevision-ai-btn:hover {
      background: #2563eb;
    }
    
    #ai-insights-output {
      color: var(--text);
      animation: fadeIn 0.3s ease;
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      background: var(--card);
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.4;
      border-left: 3px solid var(--accent);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Heatmap Button */
    .heatmap-btn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 1rem;
      font-weight: 600;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(41, 98, 255, 0.25);
      position: relative;
      overflow: hidden;
      margin-top: 1rem;
    }
    
    .heatmap-btn:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(41, 98, 255, 0.35);
    }
    
    .heatmap-icon {
      font-size: 1.4rem;
      color: #ffeb3b;
      filter: drop-shadow(0 2px 4px rgba(255, 235, 59, 0.3));
      transition: transform 0.3s ease;
    }
    
    .heatmap-btn:hover .heatmap-icon {
      transform: scale(1.1) rotate(5deg);
    }
    
    .heatmap-content {
      flex: 1;
      text-align: left;
    }
    
    .heatmap-title {
      font-size: 1rem;
      font-weight: 700;
      margin-bottom: 2px;
      letter-spacing: -0.2px;
    }
    
    .heatmap-tagline {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.85);
      font-weight: 400;
      line-height: 1.3;
    }
    
    .heatmap-arrow {
      font-size: 1rem;
      opacity: 0.8;
      transition: all 0.3s ease;
    }
    
    .heatmap-btn:hover .heatmap-arrow {
      transform: translateX(3px);
      opacity: 1;
    }
    
    /* Footer */
    .footer {
      background: var(--bg2);
      border-top: 1px solid var(--border);
      padding: 10px 16px;
      text-align: center;
      font-size: 14px;
      color: var(--muted);
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Mobile styles remain the same */
    @media (max-width: 1100px) {
      .layout {
        grid-template-columns: 52px 1fr 260px;
      }
      
      .search input {
        width: 160px;
      }
      
      .timeframe-modal {
        left: 150px;
      }
    }
    
    @media (max-width: 800px) {
      .layout {
        grid-template-columns: 52px 1fr;
      }
      
      .right-panel {
        display: none;
      }
      
      .search input {
        width: 120px;
      }
      
      .timeframe-modal {
        left: 120px;
      }
      
      .indicator-list, .timeframe-list {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 700px) {
      .header {
        flex-wrap: wrap;
        height: auto;
        min-height: 56px;
        padding: 8px;
      }
      
      .logo {
        font-size: 14px;
      }
      
      .search {
        order: 3;
        width: 100%;
        margin-top: 8px;
      }
      
      .search input {
        max-width: 100%;
      }
      
      .header-right {
        margin-left: 0;
      }
      
      .chart-topbar {
        flex-wrap: wrap;
        gap: 6px;
      }
      
      .chart-topbar .left {
        flex: 1;
      }
      
      .chart-topbar .right {
        margin-left: 0;
      }
      
      .btn {
        padding: 6px 8px;
        font-size: 12px;
      }
      
      .timeframe-modal {
        left: 100px;
        width: 200px;
      }
    }
    
    @media (max-width: 592px) {
      .layout {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      
      .left-bar {
        flex-direction: row;
        overflow-x: auto;
        padding: 8px;
        height: auto;
        min-height: 60px;
        border-right: none;
        border-bottom: 1px solid var(--border);
      }
      
      .left-bar .tool-btn {
        min-width: 60px;
      }
      
      .center {
        height: 100%;
      }
      
      .chart-topbar {
        padding: 6px 8px;
      }
      
      .chart-topbar .left {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
      }
      
      .chart-topbar .right {
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      
      .chart-controls {
        top: 8px;
        left: 8px;
      }
      
      .chart-controls button {
        padding: 6px;
      }
      
      .footer {
        font-size: 12px;
        padding: 8px;
      }
    }
  </style>
</head>

<body data-theme="dark">
  <!-- Header with embedded timeframe modal -->
  <header class="header">
    <div class="logo">
  <a href="index.html" style="color:inherit; text-decoration:none; display:flex; align-items:center; gap:8px;">
    <i class="fas fa-chart-line"></i> TradeVision
  </a>
</div>

    <div class="search">
      <input id="symbol-search" placeholder="Search assets..." value="BTCUSDT" />
      <button id="search-go" class="btn">Go</button>
      <div id="search-suggestions" class="search-suggestions"></div>

      <button id="timeframe-toggle" class="btn" style="min-width: 60px;">15m</button>

      <div style="width:8px"></div>

      <div id="chart-type-group" style="display:flex;gap:6px">
        <button class="btn chart-type-btn active" data-type="candlestick">Candles</button>
        <button class="btn chart-type-btn" data-type="line">Line</button>
        <button class="btn chart-type-btn" data-type="area">Area</button>
        <button class="btn chart-type-btn" data-type="bar">Bars</button>
      </div>
    </div>

    <div class="header-right">
      <a href="trading.html" class="btn" style="background: var(--accent); color: white;">
        <i class="fas fa-exchange-alt"></i> Trade
      </a>
	  <a href="pine-editor.html" class="btn" style="background: var(--accent); color: white;">
  <i class="fas fa-code"></i> Pine Editor
</a>
      <button id="indicators-toggle" class="btn" title="Indicators"><i class="fas fa-wave-square"></i> Indicators</button>
      <button id="theme-toggle" class="icon-btn" title="Toggle theme"><i class="fas fa-moon"></i></button>
      <a href="settings.html" class="icon-btn" title="Settings"><i class="fas fa-cog"></i></a>
      <a href="profile.html" class="icon-btn" title="Profile"><i class="fas fa-user"></i></a>
    </div>
    
    <!-- Indicators Modal -->
    <div class="indicator-modal" id="indicator-modal">
      <div style="font-weight:700;margin-bottom:8px">Indicators (select up to many)</div>
      <div class="indicator-list" id="indicator-list">
        <!-- Items populated by JS -->
      </div>
      <div style="display:flex;justify-content:flex-end;margin-top:8px;gap:8px">
        <button id="ind-apply" class="btn">Apply</button>
        <button id="ind-close" class="btn">Close</button>
      </div>
    </div>
    
    <!-- Timeframe Modal -->
    <div class="timeframe-modal" id="timeframe-modal">
      <div style="font-weight:700;margin-bottom:8px">Timeframe</div>
      <div class="timeframe-list" id="timeframe-list">
        <!-- Items populated by JS -->
      </div>
      <div style="display:flex;justify-content:flex-end;margin-top:8px;gap:8px">
        <button id="tf-close" class="btn">Close</button>
      </div>
    </div>
  </header>

  <!-- Main layout: left drawing tools, center charts, right orderbook/trades -->
  <div class="layout">
    <!-- LEFT DRAWING TOOLBAR -->
    <div class="left-bar" id="left-bar">
      <button class="tool-btn active" data-tool="cursor" title="Cursor (Select)"><i class="fas fa-mouse-pointer"></i><span>Cursor</span></button>
      <button class="tool-btn" data-tool="line" title="Line"><i class="fas fa-minus"></i><span>Line</span></button>
      <button class="tool-btn" data-tool="trendline" title="Trendline"><i class="fas fa-chart-line"></i><span>Trend</span></button>
      <button class="tool-btn" data-tool="horizontal" title="Horizontal Line"><i class="fas fa-grip-lines"></i><span>H-Line</span></button>
      <button class="tool-btn" data-tool="fib-retracement" title="Fibonacci"><i class="fas fa-ruler"></i><span>Fib</span></button>
      <button class="tool-btn" data-tool="rectangle" title="Rectangle"><i class="fas fa-square"></i><span>Rect</span></button>
      <button class="tool-btn" data-tool="text" title="Text"><i class="fas fa-font"></i><span>Text</span></button>
      <button class="tool-btn" data-tool="arrow" title="Arrow"><i class="fas fa-arrow-up"></i><span>Arrow</span></button>
      <button class="tool-btn" data-tool="clear" title="Clear all" style="margin-top: auto; background: #ef5350; color: white;"><i class="fas fa-trash"></i><span>Clear</span></button>
    </div>

    <!-- CENTER: Charts and embedded top controls -->
    <div class="center">
      <!-- Embedded top toolbar -->
      <div class="chart-topbar">
        <div class="left">
          <div style="display:flex;align-items:center;gap:10px">
            <div style="font-weight:700; margin-right:6px" id="symbol-display">BTCUSDT</div>
            <div id="price-display" style="font-weight:600;color:var(--muted)">--</div>
            <div id="change-display" style="font-weight:600"></div>
          </div>
        </div>

        <div class="right">
          <button id="snap-btn" class="btn" title="Take screenshot"><i class="fas fa-camera"></i></button>
          <button id="fullscreen-btn" class="btn" title="Fullscreen"><i class="fas fa-expand"></i></button>
          <button id="reset-zoom-btn" class="btn" title="Reset zoom"><i class="fas fa-expand-alt"></i></button>
          <button id="save-layout-btn" class="btn" title="Save layout"><i class="fas fa-save"></i></button>
        </div>
      </div>

      <!-- Chart panes -->
      <div class="chart-area">
        <div id="pricePane" class="pane">
          <div id="priceChart" class="chart-inner"></div>
          <canvas id="drawing-canvas"></canvas>
          <div class="chart-controls">
            <button id="zoom-in" title="Zoom In"><i class="fas fa-search-plus"></i></button>
            <button id="zoom-out" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
            <button id="toggle-drawings" title="Toggle drawing visibility"><i class="fas fa-pencil-alt"></i></button>
          </div>
        </div>

        <div id="volumePane" class="pane">
          <div id="volumeChart" class="chart-inner"></div>
        </div>

        <div id="indicatorPanes" style="display:flex;flex-direction:column">
          <div class="indicator-pane" id="rsiPane"><div id="rsiChart" class="chart-inner"></div></div>
          <div class="indicator-pane" id="macdPane"><div id="macdChart" class="chart-inner"></div></div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL: Orderbook & Trades -->
    <div class="right-panel" id="right-panel">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div style="font-weight:700">Market Depth & Trades</div>
        <div id="conn-status" style="font-size:12px;color:var(--muted)">Disconnected</div>
      </div>

      <div class="tab-buttons" style="margin-top:8px">
        <button class="tab-btn active" data-tab="orderbook">Orderbook</button>
        <button class="tab-btn" data-tab="trades">Trades</button>
        <button class="tab-btn" data-tab="alerts">Alerts</button>
      </div>

      <div id="tab-orderbook" class="tab-content">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <div style="font-size:13px;color:var(--muted)">Spread:</div> <div id="spread" style="font-weight:700">--</div>
        </div>
        <div class="orderbook" id="orderbook">
          <div class="col" id="asks">
            <div class="row ask" style="color: var(--muted); font-size: 11px;">
              <span>Price</span>
              <span>Amount</span>
              <span>Total</span>
            </div>
          </div>
          <div class="col" id="bids">
            <div class="row bid" style="color: var(--muted); font-size: 11px;">
              <span>Price</span>
              <span>Amount</span>
              <span>Total</span>
            </div>
          </div>
        </div>
      </div>

      <div id="tab-trades" class="tab-content" style="display:none;margin-top:8px">
        <div class="trades" id="trades-list" style="max-height:420px;overflow:auto">
          <div class="trade" style="color: var(--muted); font-size: 11px; justify-content: space-between;">
            <span>Price</span>
            <span>Amount</span>
            <span>Time</span>
          </div>
        </div>
      </div>

      <div id="tab-alerts" class="tab-content" style="display:none;margin-top:8px">
        <div class="ai-panel">
          <button id="tradevision-ai-btn">
            ðŸ¤– TradeVision AI â€“ Analyze Chart
          </button>
          <div id="ai-insights-output">
            <!-- AI response will appear here -->
          </div>
        </div>
        
        <!-- HEATMAP BUTTON SECTION -->
        <a href="heatmap.html" target="_self" class="heatmap-btn">
          <i class="fas fa-fire heatmap-icon"></i>
          <div class="heatmap-content">
            <div class="heatmap-title">Market Heatmap</div>
            <div class="heatmap-tagline">Live market performance overview</div>
          </div>
          <i class="fas fa-arrow-right heatmap-arrow"></i>
        </a>
      </div>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="footer">
    Â© 2025 TradeVision. MIT Licensed.
  </footer>

  <script>
    // â”€â”€â”€â”€â”€ GLOBALS â”€â”€â”€â”€â”€
    const DEFAULT_SYMBOL = 'BTCUSDT';
    let currentSymbol = (new URLSearchParams(location.search).get('symbol') || document.getElementById('symbol-search').value || DEFAULT_SYMBOL).toUpperCase();
    let currentInterval = '15m';
    let chartType = 'candlestick';
    let klineWs = null, tradeWs = null, depthWs = null;
    let historyData = [];
    let indicatorState = { RSI: true, MACD: true, Volume: true };
    let wsReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const CANDLE_LIMIT = 100;

    // DOM references
    const symbolSearch = document.getElementById('symbol-search');
    const searchGo = document.getElementById('search-go');
    const searchSuggestions = document.getElementById('search-suggestions');
    const timeframeToggle = document.getElementById('timeframe-toggle');
    const timeframeModal = document.getElementById('timeframe-modal');
    const timeframeList = document.getElementById('timeframe-list');
    const chartTypeBtns = document.querySelectorAll('.chart-type-btn');
    const indicatorsToggle = document.getElementById('indicators-toggle');
    const indicatorModal = document.getElementById('indicator-modal');
    const indicatorListEl = document.getElementById('indicator-list');
    const indApplyBtn = document.getElementById('ind-apply');
    const indCloseBtn = document.getElementById('ind-close');
    const tfCloseBtn = document.getElementById('tf-close');
    const connStatus = document.getElementById('conn-status');
    const symbolDisplay = document.getElementById('symbol-display');
    const priceDisplay = document.getElementById('price-display');
    const changeDisplay = document.getElementById('change-display');

    // drawing canvas
    const drawingCanvas = document.getElementById('drawing-canvas');
    const pricePaneEl = document.getElementById('pricePane');
    const leftTools = document.querySelectorAll('.left-bar .tool-btn');
    const toggleDrawBtn = document.getElementById('toggle-drawings');

    let drawingsVisible = true;
    let allSymbols = [];

    // Drawing state
    let isDrawing = false;
    let currentTool = 'cursor';
    let startX, startY;
    let drawings = [];
    let currentDrawing = null;

    // Available timeframes
    const TIMEFRAMES = [
      { interval: '1m', label: '1 minute' },
      { interval: '5m', label: '5 minutes' },
      { interval: '15m', label: '15 minutes' },
      { interval: '1h', label: '1 hour' },
      { interval: '4h', label: '4 hours' },
      { interval: '1d', label: '1 day' },
      { interval: '1w', label: '1 week' },
      { interval: '1M', label: '1 month' }
    ];

    // Available indicators (expanded to 10)
    const INDICATORS = [
      { name: 'RSI', label: 'Relative Strength Index' },
      { name: 'MACD', label: 'Moving Average Convergence Divergence' },
      { name: 'SMA', label: 'Simple Moving Average' },
      { name: 'EMA', label: 'Exponential Moving Average' },
      { name: 'Bollinger Bands', label: 'Bollinger Bands' },
      { name: 'Stochastic', label: 'Stochastic Oscillator' },
      { name: 'Volume', label: 'Volume' },
      { name: 'VWAP', label: 'Volume Weighted Average Price' },
      { name: 'ATR', label: 'Average True Range' },
      { name: 'PSAR', label: 'Parabolic SAR' }
    ];

    /* --------------------------- 
      Create lightweight-charts instances for each pane
    ----------------------------*/
    let priceChart, mainSeries, volumeChart, volumeSeries;
    let rsiChart, rsiSeries, macdChart, macdHist, macdLine, macdSignal;
    let stochChart, stochK, stochD;
    let atrChart, atrSeries;
    let smaSeries, emaSeries, bbUpper, bbMiddle, bbLower, vwapSeries, psarSeries;
    let allCharts = [];
    let indicatorCharts = {};
    let overlaySeries = {};

    function initCharts() {
      console.log('Initializing charts...');
      
      // Price chart
      priceChart = LightweightCharts.createChart(document.getElementById('priceChart'), {
        layout: { 
          background: { color: 'transparent' }, 
          textColor: getChartColor('text') 
        },
        grid: { 
          vertLines: { color: getChartColor('grid') }, 
          horzLines: { color: getChartColor('grid') } 
        },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { 
          borderColor: getChartColor('border'),
          scaleMargins: {
            top: 0.1,
            bottom: 0.2,
          }
        },
        timeScale: { 
          borderColor: getChartColor('border'), 
          timeVisible: true,
          rightOffset: 5
        },
        width: document.getElementById('priceChart').clientWidth,
        height: document.getElementById('priceChart').clientHeight
      });

      // Create main series based on chart type
      updateChartSeries();

      // Volume chart
      volumeChart = LightweightCharts.createChart(document.getElementById('volumeChart'), {
        layout: { 
          background: { color: 'transparent' }, 
          textColor: getChartColor('text') 
        },
        grid: { 
          vertLines: { color: 'transparent' }, 
          horzLines: { color: 'transparent' } 
        },
        timeScale: {
          visible: false,
          borderColor: getChartColor('border')
        },
        rightPriceScale: {
          visible: true,
          borderColor: getChartColor('border'),
          scaleMargins: {
            top: 0.8,
            bottom: 0,
          },
        },
        width: document.getElementById('volumeChart').clientWidth,
        height: 100
      });
      
      volumeSeries = volumeChart.addHistogramSeries({
        color: '#26a69a',
        priceFormat: {
          type: 'volume',
        },
        priceScaleId: 'right'
      });

      // RSI chart
      rsiChart = LightweightCharts.createChart(document.getElementById('rsiChart'), {
        layout: { 
          background: { color: 'transparent' }, 
          textColor: getChartColor('text') 
        },
        grid: { 
          vertLines: { color: getChartColor('grid') }, 
          horzLines: { color: getChartColor('grid') } 
        },
        rightPriceScale: {
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          }
        },
        timeScale: { 
          borderColor: getChartColor('border'),
          timeVisible: true
        },
        width: document.getElementById('rsiChart').clientWidth,
        height: document.getElementById('rsiChart').clientHeight
      });
      rsiSeries = rsiChart.addLineSeries({ color:'#9b6cff', lineWidth:2 });

      // MACD chart
      macdChart = LightweightCharts.createChart(document.getElementById('macdChart'), {
        layout: { 
          background: { color: 'transparent' }, 
          textColor: getChartColor('text') 
        },
        grid: { 
          vertLines: { color: getChartColor('grid') }, 
          horzLines: { color: getChartColor('grid') } 
        },
        rightPriceScale: {
          scaleMargins: {
            top: 0.3,
            bottom: 0.1,
          }
        },
        timeScale: { 
          borderColor: getChartColor('border'),
          timeVisible: true
        },
        width: document.getElementById('macdChart').clientWidth,
        height: document.getElementById('macdChart').clientHeight
      });
      macdHist = macdChart.addHistogramSeries({ 
        color: '#26a69a'
      });
      macdLine = macdChart.addLineSeries({ color:'#3399ff', lineWidth:2 });
      macdSignal = macdChart.addLineSeries({ color:'#ffa500', lineWidth:1.5 });

      allCharts = [priceChart, volumeChart, rsiChart, macdChart];

      // Synchronize charts
      synchronizeCharts();
      
      // Load initial data immediately
      loadAndRender(currentSymbol, currentInterval);
    }

    function updateChartSeries() {
      // Remove existing main series if it exists
      if (mainSeries) {
        try {
          priceChart.removeSeries(mainSeries);
        } catch (e) {
          console.log('Error removing main series:', e);
        }
      }

      // Create new series based on chart type
      if (chartType === 'candlestick') {
        mainSeries = priceChart.addCandlestickSeries({
          upColor: '#26a69a', 
          downColor: '#ef5350', 
          borderUpColor: '#26a69a',
          borderDownColor: '#ef5350', 
          wickUpColor: '#26a69a', 
          wickDownColor: '#ef5350'
        });
      } else if (chartType === 'line') {
        mainSeries = priceChart.addLineSeries({ 
          color: '#338fff', 
          lineWidth: 2 
        });
      } else if (chartType === 'area') {
        mainSeries = priceChart.addAreaSeries({
          topColor: 'rgba(51, 143, 255, 0.4)',
          bottomColor: 'rgba(51, 143, 255, 0.1)',
          lineColor: '#338fff',
          lineWidth: 2
        });
      } else if (chartType === 'bar') {
        mainSeries = priceChart.addBarSeries({
          upColor: '#26a69a',
          downColor: '#ef5350'
        });
      }
      
      // Set data if we have history data
      if (historyData && historyData.length > 0) {
        if (chartType === 'candlestick' || chartType === 'bar') {
          mainSeries.setData(historyData);
        } else {
          mainSeries.setData(historyData.map(d => ({ 
            time: d.time, 
            value: d.close 
          })));
        }
      }
      
      console.log(`Chart type updated to: ${chartType}`);
    }

    function synchronizeCharts() {
      allCharts.forEach(chart => {
        chart.timeScale().subscribeVisibleTimeRangeChange((range) => {
          if (range) {
            allCharts.forEach(otherChart => {
              if (otherChart !== chart) {
                try {
                  otherChart.timeScale().setVisibleRange(range);
                } catch (e) {
                  console.log('Sync error:', e);
                }
              }
            });
          }
        });
      });
    }

    function getChartColor(type) {
      const theme = document.body.getAttribute('data-theme');
      if (theme === 'light') {
        return {
          'bg': '#ffffff',
          'grid': '#f1f3f4',
          'text': '#2d3748',
          'border': '#e2e8f0'
        }[type];
      } else {
        return {
          'bg': '#131722',
          'grid': '#1e222d',
          'text': '#d1d4dc',
          'border': '#2c2e35'
        }[type];
      }
    }

    function updateChartColors() {
      const bg = { color: getChartColor('bg') };
      const textColor = getChartColor('text');
      const grid = { color: getChartColor('grid') };
      const border = getChartColor('border');

      allCharts.forEach(chart => {
        chart.applyOptions({
          layout: {
            background: bg,
            textColor: textColor
          },
          grid: {
            vertLines: grid,
            horzLines: grid
          },
          rightPriceScale: {
            borderColor: border
          },
          timeScale: {
            borderColor: border
          }
        });
      });
    }

    function createIndicatorChart(paneId, height = 120, options = {}) {
      const paneEl = document.createElement('div');
      paneEl.className = 'indicator-pane';
      paneEl.id = paneId + 'Pane';
      paneEl.style.height = `${height}px`;
      paneEl.style.display = 'none'; // Start hidden

      const chartEl = document.createElement('div');
      chartEl.id = paneId + 'Chart';
      chartEl.className = 'chart-inner';

      paneEl.appendChild(chartEl);
      document.getElementById('indicatorPanes').appendChild(paneEl);

      const chart = LightweightCharts.createChart(chartEl, {
        layout: { 
          background: { color: 'transparent' }, 
          textColor: getChartColor('text') 
        },
        grid: { 
          vertLines: { color: getChartColor('grid') }, 
          horzLines: { color: getChartColor('grid') } 
        },
        rightPriceScale: {
          borderColor: getChartColor('border'),
          ...(options.priceScale || {})
        },
        timeScale: { 
          borderColor: getChartColor('border'),
          timeVisible: true
        },
        width: chartEl.clientWidth,
        height: height
      });

      allCharts.push(chart);
      synchronizeCharts(); // Resync with new chart
      return chart;
    }

   /* ---------- Drawing Tools Implementation ---------- */


 /* ---------- Drawing Tools Implementation ---------- */
    function initDrawingTools() {
      const ctx = drawingCanvas.getContext('2d');
      
      // Set canvas size
      function resizeCanvas() {
        drawingCanvas.width = pricePaneEl.clientWidth;
        drawingCanvas.height = pricePaneEl.clientHeight;
        redrawAll();
      }
      
      // Redraw all drawings
      function redrawAll() {
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        ctx.strokeStyle = '#338fff';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(51, 143, 255, 0.1)';
        
        drawings.forEach(drawing => {
          drawShape(ctx, drawing);
        });
        
        if (currentDrawing) {
          drawShape(ctx, currentDrawing);
        }
      }
      
    function drawShape(ctx, drawing) {
  ctx.beginPath();
  
  switch (drawing.type) {
    case 'line':
    case 'trendline':
      ctx.moveTo(drawing.startX, drawing.startY);
      ctx.lineTo(drawing.endX, drawing.endY);
      ctx.stroke();
      break;
      
    case 'horizontal':
      ctx.moveTo(0, drawing.startY);
      ctx.lineTo(drawingCanvas.width, drawing.startY);
      ctx.stroke();
      break;
      
    case 'rectangle':
      ctx.rect(
        Math.min(drawing.startX, drawing.endX),
        Math.min(drawing.startY, drawing.endY),
        Math.abs(drawing.endX - drawing.startX),
        Math.abs(drawing.endY - drawing.startY)
      );
      ctx.stroke();
      ctx.fill();
      break;
      
    case 'fib-retracement':
  const levels = [
    { value: 0,     label: '0%' },
    { value: 0.236, label: '23.6%' },
    { value: 0.382, label: '38.2%' },
    { value: 0.5,   label: '50%' },
    { value: 0.618, label: '61.8%' },
    { value: 0.786, label: '78.6%' },
    { value: 1,     label: '100%' }
  ];

  const lowY  = Math.min(drawing.startY, drawing.endY);
  const highY = Math.max(drawing.startY, drawing.endY);
  const range = highY - lowY;

  ctx.save();
  ctx.font        = '14px Inter';
  ctx.fillStyle   = '#338fff';
  ctx.strokeStyle = '#338fff';
  ctx.lineWidth   = 1;
  ctx.textAlign   = 'right';
  ctx.textBaseline = 'top';

  levels.forEach(level => {
    const y = highY - range * level.value; // Changed to highY - range

    // LINE
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(drawingCanvas.width, y);
    ctx.stroke();

    // TEXT
    ctx.beginPath();
    ctx.fillText(level.label, drawingCanvas.width - 15, y + 4);
  });

  ctx.restore();
  break;
      
    case 'arrow':
      drawArrow(ctx, drawing.startX, drawing.startY, drawing.endX, drawing.endY);
      break;
      
    case 'text':
      ctx.font = '14px Inter';
      ctx.fillStyle = '#338fff';
      ctx.fillText(drawing.text || 'Text', drawing.startX, drawing.startY);
      break;
  }
}
      // Draw arrow
      function drawArrow(ctx, fromX, fromY, toX, toY) {
        const headlen = 10;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
      }
      
      // Mouse events for drawing
      drawingCanvas.addEventListener('mousedown', (e) => {
        if (currentTool === 'cursor') return;
        
        isDrawing = true;
        const rect = drawingCanvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        
        currentDrawing = {
          type: currentTool,
          startX: startX,
          startY: startY,
          endX: startX,
          endY: startY
        };
        
        if (currentTool === 'text') {
          const text = prompt('Enter text:', 'Text');
          if (text) {
            currentDrawing.text = text;
            drawings.push({...currentDrawing});
            currentDrawing = null;
            redrawAll();
          }
          isDrawing = false;
        }
      });
      
      drawingCanvas.addEventListener('mousemove', (e) => {
        if (!isDrawing || !currentDrawing) return;
        
        const rect = drawingCanvas.getBoundingClientRect();
        currentDrawing.endX = e.clientX - rect.left;
        currentDrawing.endY = e.clientY - rect.top;
        
        redrawAll();
      });
      
      drawingCanvas.addEventListener('mouseup', () => {
        if (!isDrawing || !currentDrawing) return;
        
        if (currentTool !== 'text') {
          drawings.push({...currentDrawing});
        }
        
        isDrawing = false;
        currentDrawing = null;
      });
      
      // Clear drawings
      document.querySelector('[data-tool="clear"]').addEventListener('click', () => {
        drawings = [];
        redrawAll();
      });
      
      // Initialize
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }

    /* ---------- Search and Symbol Management ---------- */
    async function loadAllSymbols() {
      try {
        const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
        const data = await response.json();
        
        allSymbols = data.symbols
          .filter(s => s.status === 'TRADING' && (s.quoteAsset === 'USDT' || s.quoteAsset === 'BUSD'))
          .map(s => ({
            symbol: s.symbol,
            baseAsset: s.baseAsset,
            quoteAsset: s.quoteAsset,
            name: `${s.baseAsset}/${s.quoteAsset}`
          }));
        
        console.log(`Loaded ${allSymbols.length} trading symbols`);
      } catch (error) {
        console.error('Error loading symbols:', error);
        // Fallback symbols
        allSymbols = [
          { symbol: 'BTCUSDT', baseAsset: 'BTC', quoteAsset: 'USDT', name: 'Bitcoin/USDT' },
          { symbol: 'ETHUSDT', baseAsset: 'ETH', quoteAsset: 'USDT', name: 'Ethereum/USDT' },
          { symbol: 'BNBUSDT', baseAsset: 'BNB', quoteAsset: 'USDT', name: 'Binance Coin/USDT' },
          { symbol: 'ADAUSDT', baseAsset: 'ADA', quoteAsset: 'USDT', name: 'Cardano/USDT' },
          { symbol: 'XRPUSDT', baseAsset: 'XRP', quoteAsset: 'USDT', name: 'Ripple/USDT' }
        ];
      }
    }

    function initSearch() {
      symbolSearch.addEventListener('input', (e) => {
        const query = e.target.value.trim().toUpperCase();
        
        if (query.length < 1) {
          searchSuggestions.style.display = 'none';
          return;
        }

        const matches = allSymbols
          .filter(s => 
            s.symbol.includes(query) || 
            s.baseAsset.includes(query) ||
            s.name.toUpperCase().includes(query)
          )
          .slice(0, 10);

        if (matches.length === 0) {
          searchSuggestions.innerHTML = '<div class="suggestion-item">No symbols found</div>';
        } else {
          searchSuggestions.innerHTML = matches.map(s => `
            <div class="suggestion-item" data-symbol="${s.symbol}">
              <div>
                <div class="suggestion-symbol">${s.symbol}</div>
                <div class="suggestion-name">${s.name}</div>
              </div>
              <div class="suggestion-exchange">${s.quoteAsset}</div>
            </div>
          `).join('');
        }
        
        searchSuggestions.style.display = 'block';
      });

      searchSuggestions.addEventListener('click', (e) => {
        const item = e.target.closest('.suggestion-item');
        if (item) {
          const symbol = item.dataset.symbol;
          symbolSearch.value = symbol;
          searchSuggestions.style.display = 'none';
          switchSymbol(symbol);
        }
      });

      document.addEventListener('click', (e) => {
        if (!symbolSearch.contains(e.target) && !searchSuggestions.contains(e.target)) {
          searchSuggestions.style.display = 'none';
        }
      });
    }

    /* ---------- Timeframe Modal ---------- */
    function initTimeframeModal() {
      timeframeList.innerHTML = '';
      TIMEFRAMES.forEach(tf => {
        const item = document.createElement('div');
        item.className = `timeframe-item ${tf.interval === currentInterval ? 'active' : ''}`;
        item.dataset.interval = tf.interval;
        item.textContent = tf.interval;
        timeframeList.appendChild(item);
      });

      timeframeList.addEventListener('click', (e) => {
        const item = e.target.closest('.timeframe-item');
        if (item) {
          currentInterval = item.dataset.interval;
          timeframeToggle.textContent = currentInterval;
          timeframeModal.style.display = 'none';
          reloadSymbol();
        }
      });
    }

    /* ---------- Historical data fetch (Binance REST) ---------- */
    async function fetchKlines(symbol, interval, limit=CANDLE_LIMIT){
      try {
        const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}&limit=${limit}`;
        const r = await fetch(url);
        if(!r.ok) throw new Error('Klines fetch failed');
        const data = await r.json();
        return data.map(k => ({
          time: Math.floor(k[0]/1000),
          open: parseFloat(k[1]), high: parseFloat(k[2]), low: parseFloat(k[3]), close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
      } catch (error) {
        console.error('Error fetching klines:', error);
        throw error;
      }
    }

    /* ---------- Render history to charts ---------- */
    async function loadAndRender(symbol, interval){
      try{
        console.log(`Loading data for ${symbol} ${interval}...`);
        historyData = await fetchKlines(symbol, interval, CANDLE_LIMIT);
        
        console.log('History data loaded:', historyData.length, 'candles');
        
        // Update main series data
        if (chartType === 'candlestick' || chartType === 'bar') {
          mainSeries.setData(historyData);
        } else {
          mainSeries.setData(historyData.map(d => ({ 
            time: d.time, 
            value: d.close 
          })));
        }
        
        // Volume data
        const volumeData = historyData.map(d => {
          const isUp = d.close >= d.open;
          return {
            time: d.time,
            value: d.volume,
            color: isUp ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
          };
        });
        volumeSeries.setData(volumeData);

        // Update price header
        const last = historyData[historyData.length-1];
        symbolDisplay.innerText = symbol;
        if (last) {
          priceDisplay.innerText = last.close.toFixed(2);
          // Calculate price change from previous candle
          const prev = historyData[historyData.length-2];
          if (prev) {
            const change = ((last.close - prev.close) / prev.close * 100);
            changeDisplay.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
            changeDisplay.style.color = change >= 0 ? '#26a69a' : '#ef5350';
          }
        }

        // Apply indicators
        applyIndicators(historyData);

        // Fit content to show reasonable number of candles
        setTimeout(() => {
          try {
            priceChart.timeScale().fitContent();
            volumeChart.timeScale().fitContent();
          } catch (e) {
            console.log('Fit content error:', e);
          }
        }, 300);

      }catch(e){
        console.error('loadAndRender error:', e);
        connStatus.innerText = 'Data Error';
        connStatus.style.color='#ef5350';
      }
    }

    /* ---------- Indicator Calculations ---------- */
    function calculateEMA(data, period) {
      const ema = [];
      const multiplier = 2 / (period + 1);
      
      // First EMA is just the SMA
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += data[i].close;
      }
      ema[period - 1] = sum / period;
      
      // Calculate subsequent EMAs
      for (let i = period; i < data.length; i++) {
        ema[i] = (data[i].close - ema[i-1]) * multiplier + ema[i-1];
      }
      
      return ema;
    }

    function calculateEMASeries(data, period) {
      const emaValues = calculateEMA(data, period);
      const emaData = [];
      for (let i = period - 1; i < data.length; i++) {
        emaData.push({
          time: data[i].time,
          value: emaValues[i]
        });
      }
      return emaData;
    }

    function calculateRSI(data, period = 14) {
      const rsiData = [];
      let gains = 0;
      let losses = 0;
      
      // Calculate initial averages
      for (let i = 1; i <= period; i++) {
        const change = data[i].close - data[i-1].close;
        if (change >= 0) {
          gains += change;
        } else {
          losses -= change;
        }
      }
      
      let avgGain = gains / period;
      let avgLoss = losses / period;
      
      // Calculate RSI for the rest of the data
      for (let i = period; i < data.length; i++) {
        const change = data[i].close - data[i-1].close;
        let currentGain = 0;
        let currentLoss = 0;
        
        if (change >= 0) {
          currentGain = change;
        } else {
          currentLoss = -change;
        }
        
        avgGain = (avgGain * (period - 1) + currentGain) / period;
        avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
        
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        
        rsiData.push({
          time: data[i].time,
          value: rsi
        });
      }
      
      return rsiData;
    }

    function calculateMACD(data) {
      const ema12 = calculateEMA(data, 12);
      const ema26 = calculateEMA(data, 26);
      const macdValues = [];
      for (let i = 25; i < data.length; i++) {
        macdValues.push({
          time: data[i].time,
          value: ema12[i] - ema26[i]
        });
      }

      const signalData = calculateEMASeries(macdValues.map(d => ({ time: d.time, close: d.value })), 9);

      const macdData = [];
      for (let i = 0; i < macdValues.length; i++) {
        const signal = signalData.find(s => s.time === macdValues[i].time);
        if (signal) {
          macdData.push({
            time: macdValues[i].time,
            macd: macdValues[i].value,
            signal: signal.value,
            histogram: macdValues[i].value - signal.value
          });
        }
      }
      return macdData;
    }

    function calculateSMA(data, period = 20) {
      const sma = [];
      for (let i = period - 1; i < data.length; i++) {
        let sum = 0;
        for (let j = 0; j < period; j++) {
          sum += data[i - j].close;
        }
        sma.push({ time: data[i].time, value: sum / period });
      }
      return sma;
    }

    function calculateBollinger(data, period = 20, dev = 2) {
      const smaValues = calculateSMA(data, period);
      const bb = [];
      for (let k = 0; k < smaValues.length; k++) {
        const i = k + period - 1;
        let sumSq = 0;
        for (let j = 0; j < period; j++) {
          const diff = data[i - j].close - smaValues[k].value;
          sumSq += diff * diff;
        }
        const std = Math.sqrt(sumSq / period);
        bb.push({
          time: data[i].time,
          upper: smaValues[k].value + dev * std,
          middle: smaValues[k].value,
          lower: smaValues[k].value - dev * std
        });
      }
      return bb;
    }

    function calculateStochastic(data, kPeriod = 14, dPeriod = 3) {
      const stoch = [];
      for (let i = kPeriod - 1; i < data.length; i++) {
        let minLow = Infinity;
        let maxHigh = -Infinity;
        for (let j = 0; j < kPeriod; j++) {
          minLow = Math.min(minLow, data[i - j].low);
          maxHigh = Math.max(maxHigh, data[i - j].high);
        }
        const k = ((data[i].close - minLow) / (maxHigh - minLow)) * 100;
        stoch.push({ time: data[i].time, k });
      }

      const dData = calculateSMA(stoch.map(d => ({ time: d.time, close: d.k })), dPeriod);

      const result = [];
      for (let i = 0; i < dData.length; i++) {
        const idx = i + dPeriod - 1;
        result.push({
          time: stoch[idx].time,
          k: stoch[idx].k,
          d: dData[i].value
        });
      }
      return result;
    }

    function calculateVWAP(data) {
      let cumVolume = 0;
      let cumPV = 0;
      const vwap = [];
      for (let i = 0; i < data.length; i++) {
        const typical = (data[i].high + data[i].low + data[i].close) / 3;
        cumPV += typical * data[i].volume;
        cumVolume += data[i].volume;
        if (cumVolume > 0) {
          vwap.push({ time: data[i].time, value: cumPV / cumVolume });
        }
      }
      return vwap;
    }

    function calculateATR(data, period = 14) {
      const tr = [];
      for (let i = 1; i < data.length; i++) {
        const hl = data[i].high - data[i].low;
        const hc = Math.abs(data[i].high - data[i - 1].close);
        const lc = Math.abs(data[i].low - data[i - 1].close);
        tr.push({ time: data[i].time, value: Math.max(hl, hc, lc) });
      }

      const atr = [];
      if (tr.length >= period) {
        let sum = 0;
        for (let i = 0; i < period; i++) {
          sum += tr[i].value;
        }
        let prevAtr = sum / period;
        atr.push({ time: tr[period - 1].time, value: prevAtr });

        for (let i = period; i < tr.length; i++) {
          prevAtr = (prevAtr * (period - 1) + tr[i].value) / period;
          atr.push({ time: tr[i].time, value: prevAtr });
        }
      }
      return atr;
    }

    function calculatePSAR(data, afStep = 0.02, afMax = 0.2) {
      const psar = [];
      if (data.length < 2) return psar;

      let isLong = data[1].close > data[0].close;
      let sar = isLong ? data[0].low : data[0].high;
      let ep = isLong ? data[0].high : data[0].low;
      let af = afStep;

      psar.push({ time: data[0].time, value: null });

      for (let i = 1; i < data.length; i++) {
        sar = sar + af * (ep - sar);

        if (isLong) {
          if (data[i].low < sar) {
            isLong = false;
            sar = ep;
            ep = data[i].low;
            af = afStep;
          } else {
            if (data[i].high > ep) {
              ep = data[i].high;
              af = Math.min(af + afStep, afMax);
            }
            if (i >= 2) sar = Math.max(sar, data[i-1].high, data[i-2].high);
            else sar = Math.max(sar, data[i-1].high);
          }
        } else {
          if (data[i].high > sar) {
            isLong = true;
            sar = ep;
            ep = data[i].high;
            af = afStep;
          } else {
            if (data[i].low < ep) {
              ep = data[i].low;
              af = Math.min(af + afStep, afMax);
            }
            if (i >= 2) sar = Math.min(sar, data[i-1].low, data[i-2].low);
            else sar = Math.min(sar, data[i-1].low);
          }
        }

        psar.push({ time: data[i].time, value: sar });
      }
      return psar;
    }

    /* ---------- Apply indicator state to charts ---------- */
    function applyIndicators(data) {
      if (!data || data.length === 0) return;

      // RSI
      if (indicatorState.RSI) {
        const rsiData = calculateRSI(data, 14);
        rsiSeries.setData(rsiData);
        document.getElementById('rsiPane').style.display = 'block';
      } else {
        document.getElementById('rsiPane').style.display = 'none';
      }

      // MACD
      if (indicatorState.MACD) {
        const macdData = calculateMACD(data);
        macdHist.setData(macdData.map(d => ({ time: d.time, value: d.histogram })));
        macdLine.setData(macdData.map(d => ({ time: d.time, value: d.macd })));
        macdSignal.setData(macdData.map(d => ({ time: d.time, value: d.signal })));
        document.getElementById('macdPane').style.display = 'block';
      } else {
        document.getElementById('macdPane').style.display = 'none';
      }

      // Volume
      document.getElementById('volumePane').style.display = indicatorState.Volume ? 'block' : 'none';

      // SMA (overlay)
      if (indicatorState.SMA) {
        if (!overlaySeries.SMA) {
          overlaySeries.SMA = priceChart.addLineSeries({ color: '#FFEB3B', lineWidth: 2, title: 'SMA' });
        }
        const smaData = calculateSMA(data, 20);
        overlaySeries.SMA.setData(smaData);
      } else if (overlaySeries.SMA) {
        priceChart.removeSeries(overlaySeries.SMA);
        delete overlaySeries.SMA;
      }

      // EMA (overlay)
      if (indicatorState.EMA) {
        if (!overlaySeries.EMA) {
          overlaySeries.EMA = priceChart.addLineSeries({ color: '#00E676', lineWidth: 2, title: 'EMA' });
        }
        const emaData = calculateEMASeries(data, 20);
        overlaySeries.EMA.setData(emaData);
      } else if (overlaySeries.EMA) {
        priceChart.removeSeries(overlaySeries.EMA);
        delete overlaySeries.EMA;
      }

      // Bollinger Bands (overlay)
      if (indicatorState['Bollinger Bands']) {
        if (!overlaySeries.BB_upper) {
          overlaySeries.BB_upper = priceChart.addLineSeries({ color: '#FF5252', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, title: 'BB Upper' });
          overlaySeries.BB_middle = priceChart.addLineSeries({ color: '#00E676', lineWidth: 2, title: 'BB Middle' });
          overlaySeries.BB_lower = priceChart.addLineSeries({ color: '#3D5AFE', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, title: 'BB Lower' });
        }
        const bbData = calculateBollinger(data);
        overlaySeries.BB_upper.setData(bbData.map(d => ({ time: d.time, value: d.upper })));
        overlaySeries.BB_middle.setData(bbData.map(d => ({ time: d.time, value: d.middle })));
        overlaySeries.BB_lower.setData(bbData.map(d => ({ time: d.time, value: d.lower })));
      } else {
        if (overlaySeries.BB_upper) priceChart.removeSeries(overlaySeries.BB_upper);
        if (overlaySeries.BB_middle) priceChart.removeSeries(overlaySeries.BB_middle);
        if (overlaySeries.BB_lower) priceChart.removeSeries(overlaySeries.BB_lower);
        delete overlaySeries.BB_upper;
        delete overlaySeries.BB_middle;
        delete overlaySeries.BB_lower;
      }

      // Stochastic (new pane)
      if (indicatorState.Stochastic) {
        if (!indicatorCharts.Stochastic) {
          indicatorCharts.Stochastic = createIndicatorChart('stoch', 120, {
            priceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } }
          });
          stochK = indicatorCharts.Stochastic.addLineSeries({ color: '#FF6D00', lineWidth: 2 });
          stochD = indicatorCharts.Stochastic.addLineSeries({ color: '#2962FF', lineWidth: 1.5 });
        }
        const stochData = calculateStochastic(data);
        stochK.setData(stochData.map(d => ({ time: d.time, value: d.k })));
        stochD.setData(stochData.map(d => ({ time: d.time, value: d.d })));
        document.getElementById('stochPane').style.display = 'block';
      } else {
        if (indicatorCharts.Stochastic) {
          document.getElementById('stochPane').style.display = 'none';
        }
      }

      // VWAP (overlay)
      if (indicatorState.VWAP) {
        if (!overlaySeries.VWAP) {
          overlaySeries.VWAP = priceChart.addLineSeries({ color: '#E040FB', lineWidth: 2, title: 'VWAP' });
        }
        const vwapData = calculateVWAP(data);
        overlaySeries.VWAP.setData(vwapData);
      } else if (overlaySeries.VWAP) {
        priceChart.removeSeries(overlaySeries.VWAP);
        delete overlaySeries.VWAP;
      }

      // ATR (new pane)
      if (indicatorState.ATR) {
        if (!indicatorCharts.ATR) {
          indicatorCharts.ATR = createIndicatorChart('atr', 120);
          atrSeries = indicatorCharts.ATR.addLineSeries({ color: '#9C27B0', lineWidth: 2 });
        }
        const atrData = calculateATR(data);
        atrSeries.setData(atrData);
        document.getElementById('atrPane').style.display = 'block';
      } else {
        if (indicatorCharts.ATR) {
          document.getElementById('atrPane').style.display = 'none';
        }
      }

      // PSAR (overlay)
      if (indicatorState.PSAR) {
        if (!overlaySeries.PSAR) {
          overlaySeries.PSAR = priceChart.addLineSeries({
            color: '#F50057',
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.SparseDotted,
            lastValueVisible: false,
            priceLineVisible: false,
            title: 'PSAR'
          });
        }
        const psarData = calculatePSAR(data);
        overlaySeries.PSAR.setData(psarData.filter(d => d.value !== null).map(d => ({ time: d.time, value: d.value })));
      } else if (overlaySeries.PSAR) {
        priceChart.removeSeries(overlaySeries.PSAR);
        delete overlaySeries.PSAR;
      }
    }

    /* ---------- WebSocket connections (Binance REAL) ---------- */
    function connectBinanceStreams(symbol, interval){
      disconnectStreams();
      wsReconnectAttempts = 0;

      const s = symbol.toLowerCase();
      const klineStream = `${s}@kline_${interval}`;
      const tradeStream = `${s}@trade`;
      const depthStream = `${s}@depth20@100ms`;

      // Kline WebSocket
      try {
        klineWs = new WebSocket(`wss://stream.binance.com:9443/ws/${klineStream}`);
        klineWs.onopen = ()=> { 
          console.log('kline ws open'); 
          updateConnectionStatus('Connected', '#26a69a');
          wsReconnectAttempts = 0;
        };
        
        klineWs.onmessage = evt => {
          try{
            const msg = JSON.parse(evt.data);
            if(msg.k){
              const k = msg.k;
              const bar = { time: Math.floor(k.t/1000), open: +k.o, high: +k.h, low: +k.l, close: +k.c, volume: +k.v };
              
              if(k.x){
                // Finalized candle
                const last = historyData[historyData.length-1];
                if(!last || bar.time > last.time) historyData.push(bar);
                else historyData[historyData.length-1] = bar;
                
                // Keep only the last CANDLE_LIMIT candles
                if (historyData.length > CANDLE_LIMIT) {
                  historyData = historyData.slice(-CANDLE_LIMIT);
                }
                
                // Update main series
                if (chartType === 'candlestick' || chartType === 'bar') {
                  mainSeries.update(bar);
                } else {
                  mainSeries.update({ time: bar.time, value: bar.close });
                }
                
                // Update volume
                const isUp = bar.close >= bar.open;
                volumeSeries.update({
                  time: bar.time,
                  value: bar.volume,
                  color: isUp ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                });

                // Update indicators on closed candle
                applyIndicators(historyData);
              } else {
                // Update current candle (main and volume only)
                if (chartType === 'candlestick' || chartType === 'bar') {
                  mainSeries.update(bar);
                } else {
                  mainSeries.update({ time: bar.time, value: bar.close });
                }
                const isUp = bar.close >= bar.open;
                volumeSeries.update({
                  time: bar.time,
                  value: bar.volume,
                  color: isUp ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                });
              }
              
              priceDisplay.innerText = bar.close.toFixed(2);
            }
          }catch(e){ console.error('Kline message error:', e); }
        };
        
        klineWs.onclose = ()=> { 
          console.warn('kline ws closed'); 
          updateConnectionStatus('Disconnected', '#ef5350');
          attemptReconnect(symbol, interval);
        };
        
        klineWs.onerror = (e)=> { 
          console.error('kline ws error', e); 
          klineWs.close(); 
        };
      } catch (error) {
        console.error('Failed to create kline WebSocket:', error);
        attemptReconnect(symbol, interval);
      }

      // Trade WebSocket
      try {
        tradeWs = new WebSocket(`wss://stream.binance.com:9443/ws/${tradeStream}`);
        tradeWs.onmessage = evt => {
          try {
            const msg = JSON.parse(evt.data);
            const price = parseFloat(msg.p);
            const quantity = parseFloat(msg.q);
            const isBuyerMaker = msg.m;
            const time = msg.T;
            
            // Update trades list
            addTradeToList({
              price, 
              qty: quantity, 
              isBuyerMaker, 
              time
            });
          } catch (error) {
            console.error('Trade message error:', error);
          }
        };
        
        tradeWs.onopen = ()=> console.log('trade ws open');
        tradeWs.onclose = ()=> { attemptReconnect(symbol, interval); };
        tradeWs.onerror = (e)=> { console.error('trade ws error', e); tradeWs.close(); };
      } catch (error) {
        console.error('Failed to create trade WebSocket:', error);
      }

      // Depth WebSocket
      try {
        depthWs = new WebSocket(`wss://stream.binance.com:9443/ws/${depthStream}`);
        depthWs.onmessage = evt => {
          try {
            const msg = JSON.parse(evt.data);
            updateOrderbook(msg);
          } catch (error) {
            console.error('Depth message error:', error);
          }
        };
        
        depthWs.onopen = ()=> {
          console.log('depth ws open');
          // Initialize with empty orderbook
          initializeOrderbook();
        };
        depthWs.onclose = ()=> { attemptReconnect(symbol, interval); };
        depthWs.onerror = (e)=> { console.error('depth ws error', e); depthWs.close(); };
      } catch (error) {
        console.error('Failed to create depth WebSocket:', error);
      }
    }

    function updateConnectionStatus(status, color) {
      connStatus.innerText = status;
      connStatus.style.color = color;
    }

    function initializeOrderbook() {
      const bidsContainer = document.getElementById('bids');
      const asksContainer = document.getElementById('asks');
      
      if (!bidsContainer || !asksContainer) return;
      
      // Clear existing content except headers
      bidsContainer.innerHTML = '<div class="row bid" style="color: var(--muted); font-size: 11px;"><span>Price</span><span>Amount</span><span>Total</span></div>';
      asksContainer.innerHTML = '<div class="row ask" style="color: var(--muted); font-size: 11px;"><span>Price</span><span>Amount</span><span>Total</span></div>';
      
      document.getElementById('spread').textContent = '--';
    }

    function addTradeToList(trade) {
      const tradesList = document.getElementById('trades-list');
      if (!tradesList) return;
      
      const tradeEl = document.createElement('div');
      tradeEl.className = `trade ${trade.isBuyerMaker ? 'sell' : 'buy'}`;
      
      const time = new Date(trade.time).toLocaleTimeString();
      const priceColor = trade.isBuyerMaker ? '#ef5350' : '#26a69a';
      
      tradeEl.innerHTML = `
        <span style="color: ${priceColor}">${trade.price.toFixed(2)}</span>
        <span>${trade.qty.toFixed(4)}</span>
        <span style="color: var(--muted); font-size: 11px;">${time}</span>
      `;
      
      // Add to top of list (after header)
      const header = tradesList.firstChild;
      tradesList.insertBefore(tradeEl, header.nextSibling);
      
      // Limit list length (keep header + 20 trades)
      while (tradesList.children.length > 21) {
        tradesList.removeChild(tradesList.lastChild);
      }
    }

    function updateOrderbook(depthData) {
      const bidsContainer = document.getElementById('bids');
      const asksContainer = document.getElementById('asks');
      
      if (!bidsContainer || !asksContainer) return;
      
      // Clear existing content except headers
      bidsContainer.innerHTML = '<div class="row bid" style="color: var(--muted); font-size: 11px;"><span>Price</span><span>Amount</span><span>Total</span></div>';
      asksContainer.innerHTML = '<div class="row ask" style="color: var(--muted); font-size: 11px;"><span>Price</span><span>Amount</span><span>Total</span></div>';
      
      // Process bids (buy orders) - take top 10
      const bids = depthData.bids.slice(0, 10).map(([price, quantity]) => ({
        price: parseFloat(price),
        quantity: parseFloat(quantity)
      }));
      
      // Process asks (sell orders) - take top 10
      const asks = depthData.asks.slice(0, 10).map(([price, quantity]) => ({
        price: parseFloat(price),
        quantity: parseFloat(quantity)
      }));
      
      // Update bids
      bids.forEach(bid => {
        const row = document.createElement('div');
        row.className = 'row bid';
        const total = (bid.price * bid.quantity).toFixed(2);
        row.innerHTML = `
          <span style="color: #26a69a">${bid.price.toFixed(2)}</span>
          <span>${bid.quantity.toFixed(4)}</span>
          <span style="color: var(--muted)">${total}</span>
        `;
        bidsContainer.appendChild(row);
      });
      
      // Update asks
      asks.forEach(ask => {
        const row = document.createElement('div');
        row.className = 'row ask';
        const total = (ask.price * ask.quantity).toFixed(2);
        row.innerHTML = `
          <span style="color: #ef5350">${ask.price.toFixed(2)}</span>
          <span>${ask.quantity.toFixed(4)}</span>
          <span style="color: var(--muted)">${total}</span>
        `;
        asksContainer.appendChild(row);
      });
      
      // Update spread
      if (bids.length > 0 && asks.length > 0) {
        const bestBid = bids[0].price;
        const bestAsk = asks[0].price;
        const spread = bestAsk - bestBid;
        const spreadPercent = (spread / bestBid) * 100;
        
        document.getElementById('spread').textContent = 
          `${spread.toFixed(2)} (${spreadPercent.toFixed(2)}%)`;
      }
    }

    function attemptReconnect(symbol, interval) {
      if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
        wsReconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 30000);
        console.log(`Attempting reconnect ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);
        
        updateConnectionStatus(`Reconnecting (${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, '#ffa500');
        
        setTimeout(() => {
          connectBinanceStreams(symbol, interval);
        }, delay);
      } else {
        console.error('Max reconnection attempts reached');
        updateConnectionStatus('Connection Failed', '#ef5350');
      }
    }

    function disconnectStreams() {
      if (klineWs) {
        klineWs.onclose = null;
        klineWs.close();
        klineWs = null;
      }
      if (tradeWs) {
        tradeWs.onclose = null;
        tradeWs.close();
        tradeWs = null;
      }
      if (depthWs) {
        depthWs.onclose = null;
        depthWs.close();
        depthWs = null;
      }
    }

    /* ---------- UI interactions & wiring ---------- */
    // search / switch symbol
    searchGo.addEventListener('click', ()=> switchSymbol(symbolSearch.value.trim().toUpperCase()));
    symbolSearch.addEventListener('keypress', (e)=> { if(e.key==='Enter') switchSymbol(symbolSearch.value.trim().toUpperCase()); });

    // timeframe modal
    timeframeToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      timeframeModal.style.display = timeframeModal.style.display === 'block' ? 'none' : 'block';
      indicatorModal.style.display = 'none';
    });

    // chart type toggles
    chartTypeBtns.forEach(b=>{
      b.addEventListener('click', ()=> {
        chartTypeBtns.forEach(x=> x.classList.remove('active'));
        b.classList.add('active');
        chartType = b.dataset.type;
        updateChartSeries();
      });
    });

    // indicators modal
    indicatorsToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      indicatorModal.style.display = indicatorModal.style.display === 'block' ? 'none' : 'block';
      timeframeModal.style.display = 'none';
      
      // Initialize indicator list if not already done
      if (indicatorListEl.children.length === 0) {
        INDICATORS.forEach(ind => {
          const item = document.createElement('div');
          item.className = `indicator-item ${indicatorState[ind.name] ? 'active' : ''}`;
          item.dataset.name = ind.name;
          item.textContent = ind.name;
          indicatorListEl.appendChild(item);
        });
      }
    });

    // indicator selection
    indicatorListEl.addEventListener('click', (e) => {
      const item = e.target.closest('.indicator-item');
      if (item) {
        item.classList.toggle('active');
      }
    });

    // apply indicators
    indApplyBtn.addEventListener('click', () => {
      // Update indicator state based on selection
      document.querySelectorAll('.indicator-item').forEach(item => {
        const name = item.dataset.name;
        indicatorState[name] = item.classList.contains('active');
      });
      
      // Apply indicators to chart
      applyIndicators(historyData);
      
      // Close modal
      indicatorModal.style.display = 'none';
    });

    // close modals
    indCloseBtn.addEventListener('click', () => {
      indicatorModal.style.display = 'none';
    });

    tfCloseBtn.addEventListener('click', () => {
      timeframeModal.style.display = 'none';
    });

    // close modals when clicking outside
    document.addEventListener('click', (e) => {
      if (!indicatorModal.contains(e.target) && e.target !== indicatorsToggle) {
        indicatorModal.style.display = 'none';
      }
      if (!timeframeModal.contains(e.target) && e.target !== timeframeToggle) {
        timeframeModal.style.display = 'none';
      }
    });

    // theme toggle
    document.getElementById('theme-toggle').addEventListener('click', () => {
      const currentTheme = document.body.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', newTheme);
      
      // Update icon
      const icon = document.querySelector('#theme-toggle i');
      icon.className = newTheme === 'dark' ? 'fas fa-moon' : 'fas fa-sun';

      // Update charts
      updateChartColors();
    });

    // tab switching
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        
        // Update active tab button
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Show selected tab content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        document.getElementById(`tab-${tab}`).style.display = 'block';
      });
    });

    // drawing tools
    leftTools.forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.dataset.tool === 'clear') {
          // Clear drawings
          const ctx = drawingCanvas.getContext('2d');
          ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
          drawings = [];
          return;
        }
        
        leftTools.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        
        // Set cursor style
        drawingCanvas.style.cursor = currentTool === 'cursor' ? 'default' : 'crosshair';
      });
    });

    // toggle drawings visibility
    toggleDrawBtn.addEventListener('click', () => {
      drawingsVisible = !drawingsVisible;
      drawingCanvas.style.display = drawingsVisible ? 'block' : 'none';
      toggleDrawBtn.style.color = drawingsVisible ? 'var(--accent)' : 'var(--muted)';
    });

    // chart controls
    document.getElementById('zoom-in').addEventListener('click', () => {
      priceChart.timeScale().applyOptions({
        barSpacing: Math.max(0.5, priceChart.timeScale().options().barSpacing * 0.8)
      });
    });

    document.getElementById('zoom-out').addEventListener('click', () => {
      priceChart.timeScale().applyOptions({
        barSpacing: priceChart.timeScale().options().barSpacing * 1.25
      });
    });

    document.getElementById('reset-zoom-btn').addEventListener('click', () => {
      priceChart.timeScale().fitContent();
    });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
      const center = document.querySelector('.center');
      if (!document.fullscreenElement) {
        center.requestFullscreen().catch(err => {
          console.error(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    });

    document.getElementById('snap-btn').addEventListener('click', () => {
      alert('Screenshot functionality would be implemented here');
    });

    document.getElementById('save-layout-btn').addEventListener('click', () => {
      alert('Layout saved!');
    });

    // AI Insights button
    document.getElementById('tradevision-ai-btn').addEventListener('click', () => {
      const output = document.getElementById('ai-insights-output');
      output.style.display = 'block';
      output.innerHTML = '<div style="text-align:center"><i class="fas fa-spinner fa-spin"></i> Analyzing chart...</div>';
      
      setTimeout(() => {
        const insights = [
          "The current trend appears bullish with higher highs and higher lows.",
          "RSI is in neutral territory (around 55), suggesting room for movement in either direction.",
          "Volume has been increasing on up moves, confirming buyer interest.",
          "MACD shows positive momentum with the histogram trending upward.",
          "Key resistance level at $52,000; break above could signal further upside.",
          "Support appears strong around $48,500 based on recent price action.",
          "Consider a long position with a stop loss below $48,000 for risk management."
        ];
        
        const randomInsight = insights[Math.floor(Math.random() * insights.length)];
        output.innerHTML = `<strong>TradeVision AI Analysis:</strong><br>${randomInsight}`;
      }, 1500);
    });

    // Resize handler for charts
    window.addEventListener('resize', () => {
      allCharts.forEach(chart => {
        const container = chart.container();
        if (container) {
          chart.resize(container.clientWidth, container.clientHeight);
        }
      });
    });

    /* ---------- Symbol switching / lifecycle ---------- */
    async function switchSymbol(symbol){
      if(!symbol) return;
      
      if(symbol.includes(':')) symbol = symbol.split(':').pop();
      currentSymbol = symbol.toUpperCase();
      symbolSearch.value = currentSymbol;
      symbolDisplay.innerText = currentSymbol;
      
      await loadAndRender(currentSymbol, currentInterval);
      connectBinanceStreams(currentSymbol, currentInterval);
    }

    /* reload symbol history */
    async function reloadSymbol(){
      await loadAndRender(currentSymbol, currentInterval);
      connectBinanceStreams(currentSymbol, currentInterval);
    }

    /* ---------- initialization ---------- */
    async function initializeApp() {
      console.log('Initializing TradeVision...');
      
      // Check if LightweightCharts is loaded
      if (typeof LightweightCharts === 'undefined') {
        console.error('Lightweight Charts library not loaded!');
        return;
      }
      
      await loadAllSymbols();
      initCharts();
      initSearch();
      initTimeframeModal();
      initDrawingTools(); // Initialize drawing tools
      
      // Set initial timeframe button text
      timeframeToggle.textContent = currentInterval;
      
      // Connect WebSockets immediately after charts are ready
      setTimeout(() => {
        connectBinanceStreams(currentSymbol, currentInterval);
      }, 1000);
      
      console.log('TradeVision initialized successfully');
    }

    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>
